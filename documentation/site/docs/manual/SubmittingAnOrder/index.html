<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Submitting an Order - Pax Financial Examples</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.1.2, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="../../.." target="_blank" class="custom-link">Pax Financial Examples</a>
</li>
<li class="divider"></li>
<li class="header">Documentation</li>

<li>
<a href="../Introduction/" class="">Introduction</a>
</li>

<li>
<a href="../GettingStarted/" class="">Getting Started</a>
</li>

<li>
<a href="./" class="active">Submitting an Order</a>
</li>

<li class="header">Endpoints</li>

<li>
<a href="../../endpoints/get_historical_hour/" class="">get_historical_hour</a>
</li>

<li>
<a href="../../endpoints/submit_single_market_order/" class="">submit_single_market_order</a>
</li>

<li>
<a href="../../endpoints/model/" class="">model</a>
</li>

<li class="header">Examples</li>

<li>
<a href="../../../examples/ReadingFinancialData/" class="">Reading Financial Data</a>
</li>

<li>
<a href="../../../examples/TensorflowModelVolatility/" class="">Volatility Model</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="submitting-an-order">Submitting an Order</h1>
<p>In this example we show how to use the Pax Financial API to submit a market order in a simulation. We will place money in our account, submit an order, have the API check that it is possible to fill the order and fill it if possible, and view the filled order and our account holdings.      </p>
<h2 id="1-importing-the-pdk-and-instantiating-the-api">1. Importing the PDK and Instantiating the API</h2>
<p>We begin by importing the Pax Development Kit and instantiating the Pax Financial API. Upon executing the following cell you should see as output <code>PaxFinancialAPI v4 loaded!</code> (or something similar).</p>
<pre><code class="python">import paxdk

import json
with open(&quot;../.config&quot;) as f:
    data = json.load(f)
api_key = data['api_key'] 

pq = paxdk.PaxFinancialAPI(url_version='dev',api_key=api_key)
</code></pre>

<pre><code>PaxFinancialAPI v4 loaded!
</code></pre>
<h2 id="2-generating-an-experiment-id">2. Generating an Experiment ID</h2>
<p>Every experiment requires an experiment ID, so we generate a unique  but descriptive ID to use. </p>
<pre><code class="python">import uuid
eid = 'test_market_order-'+str(uuid.uuid1())
print(eid)
</code></pre>

<pre><code>test_market_order-ed987e8a-a5bb-11ea-b2d5-1b6781e48145
</code></pre>
<h2 id="3-loading-funds-into-our-account">3. Loading Funds Into Our Account</h2>
<p>We begin by putting some cash into the holdings associated with this experiment ID. We will load the account with USD10,000. 
The argument <code>'symbol'</code> specifies the ticker symbol for the security or currency in the transaction, which is 'USDT' for US dollars.  The <code>'quantity'</code> 10000 is the number of US dollars credited to our account in the transaction. The <code>'date'</code> is the simulation datetime at which the transaction occurs. We will have our transaction occurring at 9:00 am, April 1, 2020. </p>
<pre><code class="python">## 1  Put some cash into this EID
import datetime
transdat = pq.submit_transaction({
                                'experiment_id': eid,
                                'symbol': 'USDT',
                                'quantity': 10000,
                                'value': 10000,
                                'date':datetime.datetime(2020,4,1,9),
                                'unit_price': 1.0,
                                'account_currency': 'USDT',
                                'type': 'algorithm',
                                'note': &quot;Initial Cash Deposit&quot;,
                                #'do_not_update_holdings':True,
                                'api_key':api_key},remote=True)
print(transdat)
assert 'transaction_id' in transdat.keys()
assert 'quantity' in transdat.keys()
assert 'symbol' in transdat.keys()

</code></pre>

<pre><code>{'transaction_id': 't-24458380-3305-4048-9def-b0e7bcaac27e', 'quantity': '10000', 'symbol': 'USDT'}
</code></pre>
<p>The <code>pq.submit_transaction()</code> API call returns a dictionary containing a <code>transaction_id</code> and the quantity and symbol of the transaction.</p>
<h2 id="4-submitting-an-order">4. Submitting an Order</h2>
<p>Now we will submit an order to buy BitCoin ('BTC').  The <code>from_symbol</code> is the currency our account is ('USDT' i.e. US dollars), the <code>to_symbol</code> is the security or currency we're buying. The <code>to_quantity</code> is the amount to buy. We will specify that we want to buy 0.1 BitCoin. We must specify the order type, which is either 'BUY' or 'SELL'.  In this case it is 'BUY'. The <code>purchase_date</code> is the simulation datetime (as opposed to the real datetime) at which the BUY order takes effect (i.e. you are requesting to buy after this time). We must also provide a <code>'limit_date'</code>, which is the simulation datetime at which the order will expire if it has not been filled. Here we choose a <code>'limit_date'</code> of 1 day after the order comes into effect.   </p>
<pre><code class="python">from_symbol = 'USDT'
to_symbol = 'BTC'
to_quantity = 0.1
order_type = 'BUY'
purchase_date = datetime.datetime(2020,4,1,10)
limit_date = purchase_date + datetime.timedelta(days=1)

dat = pq.submit_single_market_order({'from_symbol':from_symbol,
                            'to_symbol': to_symbol,
                            'to_quantity': to_quantity,
                            'experiment_id':eid,
                            'type': order_type,
                            'purchase_date':purchase_date,
                            'tag':&quot;test submit&quot;,
                            #'limit_value': None,
                            'limit_date': limit_date,
                            'symbol_discovery':'BINANCE',
                            #'market_price':None,
                            #'avg_fill_price':None,
                            #'market_status':None,
                            #'status':'simulated',
                            #'transaction_fee':min([proceeds*0.005,0.01*proceeds])*2,
                            #'transaction_ids':transaction_ids}
                              })    
print(dat)
assert 'order_id' in dat.keys()
assert 'experiment_id' in dat.keys()
assert dat['experiment_id'] == eid
assert 'status' in dat.keys()
assert dat['status'] == 'pending'
assert 'from_symbol' in dat.keys()
assert 'to_symbol' in dat.keys()
assert 'to_quantity' in dat.keys()
</code></pre>

<pre><code>{'from_symbol': 'USDT', 'order_id': 'ro-78e234bf-854e-4fae-9c85-95c77c9af1cd', 'to_symbol': 'BTC', 'to_quantity': 0.1, 'experiment_id': 'test_market_order-ed987e8a-a5bb-11ea-b2d5-1b6781e48145', 'type': 'BUY', 'purchase_date': datetime.datetime(2020, 4, 1, 10, 0), 'submitted_date': datetime.datetime(2020, 4, 1, 10, 0), 'tag': 'test submit', 'limit_price_top': None, 'limit_price_bottom': None, 'limit_date': datetime.datetime(2020, 4, 2, 10, 0), 'simulated_price': None, 'symbol_discovery': 'BINANCE', 'market_price': None, 'market_status': 'pending', 'status': 'pending', 'avg_fill_price': None, 'market_avg_fill_price': None, 'transaction_fee': None, 'transaction_ids': [], '_id': None}
</code></pre>
<p>The <code>pq.submit_single_order()</code> API call returns a dictionary with information about the order.  Note in particular the <code>'status'</code> field, which should have the value <code>'pending'</code>.  The initial status of an order upon submission is always <code>'pending'</code>. The order status will remain <code>'pending'</code> until we call <code>pq.manage_experiment()</code>, which is the task of the next code cell.</p>
<h2 id="5-filling-the-order">5. Filling the Order</h2>
<p>The <code>pq.manage_experiment()</code> API call checks the orders for the <code>'experiment_id'</code> to see if there are any <code>'pending'</code> orders that can be filled at the <code>'current_date'</code> (which is actually a datetime) specified. If there are, it will fill the orders, making the appropriate transfers of assets and currency to and from the account. We are calling <code>pq.manage_experiment()</code> with <code>'current_date'</code> equal to one hour after our order came into effect i.e. 11:00 am April 1, 2020. </p>
<pre><code class="python">dat = pq.manage_experiment({'api_key':api_key,
                                    'current_date': datetime.datetime(2020,4,1,11),
                                    'base_symbol':'USDT',
                                    'symbol_discovery':'BINANCE',
                                    'experiment_id':eid,},remote=True)
print(dat)
assert dat is True
</code></pre>

<pre><code>True
</code></pre>
<p>A successful call to <code>'pq.manage_experiment()'</code> will return with the value <code>True</code>. </p>
<h2 id="6-checking-if-the-order-was-filled">6. Checking If the Order Was Filled</h2>
<p>To see if the order was filled we call <code>pq.find_algorithm_single_orders()</code>: </p>
<pre><code class="python">q = {'experiment_id':eid}
dat = pq.find_algorithm_single_orders(q,remote=True)
print(dat)
assert 'order_id' in dat[0].keys()
assert 'experiment_id' in dat[0].keys()
assert dat[0]['experiment_id'] == eid
assert 'status' in dat[0].keys()
assert 'from_symbol' in dat[0].keys()
assert 'to_symbol' in dat[0].keys()
assert 'to_quantity' in dat[0].keys()
</code></pre>

<pre><code>[{'from_symbol': 'USDT', 'order_id': 'ro-78e234bf-854e-4fae-9c85-95c77c9af1cd', 'to_symbol': 'BTC', 'to_quantity': 0.1, 'experiment_id': 'test_market_order-ed987e8a-a5bb-11ea-b2d5-1b6781e48145', 'type': 'BUY', 'purchase_date': datetime.datetime(2020, 4, 1, 10, 0), 'submitted_date': datetime.datetime(2020, 4, 1, 10, 0), 'tag': 'test submit,Simulated Buy Fill', 'limit_price_top': None, 'limit_price_bottom': None, 'limit_date': datetime.datetime(2020, 4, 2, 10, 0), 'simulated_price': 6318.89, 'symbol_discovery': 'BINANCE', 'market_price': None, 'market_status': 'pending', 'status': 'filled', 'avg_fill_price': 6318.89, 'market_avg_fill_price': None, 'transaction_fee': None, 'transaction_ids': [], 'account_id': 'justingirard@justingirard.com'}]
</code></pre>
<p><code>pq.find_algorithm_single_orders()</code> provides information about all orders submitted by the experiment. In this case there is only one order submitted so we obtain a one-element list. If the order has been filled the <code>'status'</code> will now be <code>'filled'</code> and the field <code>'avg_fill_price'</code> will state the price that was paid.</p>
<h2 id="7-viewing-our-account-holdings">7. Viewing Our Account Holdings</h2>
<p>Next we will call <code>'pq.get_approx_holdings'</code> to see what our experiment's holdings are.  The holdings are "approximate" in the sense that they are calculated by updating holdings in real-time as opposed to from a transaction history. </p>
<pre><code class="python">dat = pq.get_approx_holdings({'api_key':api_key,'experiment_id':eid},remote=True)
print(dat)
assert 'USDT' in dat.keys()
assert 'BTC' in dat.keys()
</code></pre>

<pre><code>{'USDT': 9367.47279211, 'BTC': 0.1}
</code></pre>
<p>In the dictionary returned from <code>pq.get_approx_holdings()</code> we can see the amounts of US dollars we hold, as well as the amount of BitCoin if the order placed above was successfully filled.</p>
<pre><code class="python">
</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</body>
</html>